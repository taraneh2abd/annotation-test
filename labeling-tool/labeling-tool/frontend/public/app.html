<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Image Labeling Tool</title>
<style>
.card.focus { box-shadow: 0 0 0 5px #3b82f6 inset; }
.card.pos.focus { box-shadow: 0 0 0 5px #10b981 inset; }
.card.neg.focus { box-shadow: 0 0 0 5px #ef4444 inset; }
/* .card p { text-align: center; font-size: 7px; color: #cbd5e1; margin: 3px 0 0; } */

body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 0; background: #0f172a; color: #e2e8f0; }
header { padding: 16px 24px; background: #111827; position: sticky; top: 0; z-index: 10; display: flex; align-items: center; gap: 12px; }
h1 { font-size: 20px; margin: 0; }
.container { padding: 16px 24px; }
button { background: #1f2937; color: #e5e7eb; border: 1px solid #334155; padding: 8px 12px; border-radius: 10px; cursor: pointer; }
button:hover { background: #374151; }
.status { opacity: 0.8; font-size: 14px; }
.query { margin: 16px 0; text-align: center; }
.query img { max-height: 400px; max-width: 560px; border-radius: 12px; display: inline-block; border: 1px solid #334155; }
.grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; max-height: 450px; overflow-y: auto; padding: 20px;}
.card {
  position: relative;
  text-align: center;
  position: relative;
  border-radius: 12px;
  background: #0b1220;
  border: none;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: stretch;
}

/* image container fills top of card */
.imgWrap {
  position: relative;
  border: 1px solid #334155;
  border-radius: 12px;
  overflow: hidden;
  flex-shrink: 0;
  aspect-ratio: 1 / 1;     /* keeps image area square */
}

/* image fits naturally inside */
.imgWrap img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  background-color: #111827;
  display: block;
}

/* caption now naturally below image */
.card p {
  position: absolute;
  bottom: 4px;
  left: 50%;
  transform: translateX(-50%);
  display: inline-block;          /* ✅ background hugs text */
  background: #000;
  border-radius: 8px;
  padding: 2px 6px;
  font-size: 9px;
  color: #ffffff;
  z-index: 5;
  box-shadow: 0 0 4px rgba(0,0,0,0.5);
  width: fit-content;             /* ✅ only as wide as text */
  pointer-events: none;
}
/* ✅ green/red borders only around image area now */
.imgWrap.pos { box-shadow: 0 0 0 3px #10b981 inset; }
.imgWrap.neg { box-shadow: 0 0 0 3px #ef4444 inset; }

.card img { width: 100%; height: 140px; object-fit: cover; display: block; }
.pos { box-shadow: 0 0 0 3px #10b981 inset; }
.neg { box-shadow: 0 0 0 3px #ef4444 inset; }
.hint { font-size: 13px; opacity: .8; }
.footer { padding: 16px 24px; opacity: 0.7; font-size: 13px; }
a { color: #93c5fd; }

.layout { display: flex; gap: 20px; }
.left-panel { flex: 1; display: flex; flex-direction: column; gap: 16px; align-items: center; }
.right-panel { flex: 5; }
.controls { display: flex; gap: 10px; align-items: center; }
.batch-nav { display: flex; flex-direction: column; align-items: center; gap: 6px; }
.batch-nav .controls-row { display: flex; align-items: center; gap: 8px; }
.batch-nav .hints { font-size: 13px; color: #cbd5e1; line-height: 1.4; text-align: center; }
.batch-nav button { padding: 6px 10px; font-weight: bold; }

.queryWrap { position: relative; display: inline-block; }
.queryWrap .badge.pos { left: 6px; top: 6px; }
.queryWrap .badge.neg { right: 6px; top: 6px; }

.badge {
  position: absolute;
  top: 6px;
  width: 22px;
  height: 22px;
  line-height: 22px;
  border-radius: 50%;
  font-size: 12px;
  font-weight: bold;
  text-align: center;
  color: #fff;
  pointer-events: none;
}
.badge.pos { left: 6px; background-color: #10b981; }
.badge.neg { right: 6px; background-color: #ef4444; }
</style>
</head>
<body>
<header>
  <h1>Image Labeling Tool</h1>
  <div class="status" id="status"></div>
</header>

<div class="container">
  <div class="layout">
    <div class="left-panel">
      <section class="query">
        <h3>Query Image</h3>
        <div class="queryWrap">
          <img id="queryImg" alt="Query" />
          <!-- badges injected by JS -->
        </div>
      </section>

      <div class="batch-nav">
        <div class="controls-row">
          <button id="prevBatch">&lt;</button>
          <span id="batchCounter">0 / 0</span>
          <button id="nextBatch">&gt;</button>
        </div>
        <div class="hints">
          <p><strong>Ctrl → / Ctrl ←</strong> will save automatically</p>
          <p><strong>Left click:</strong> positive, <strong>Right click:</strong> negative</p>
        </div>
      </div>

      <div class="controls">
        <button id="save">Save Selections</button>
      </div>
    </div>

    <div class="right-panel">
      <section>
        <h3>Candidates</h3>
        <div class="grid" id="grid"></div>
      </section>
    </div>
  </div>
</div>

<script>
const API = 'http://localhost:8000';
const TOKEN = localStorage.getItem('TOKEN');
if(!TOKEN) window.location.href='index.html';

/* ---------- Path helpers (normalize always to relative) ---------- */
function toRelative(url){
  if (!url) return url;
  // strip origin if present
  try {
    const u = new URL(url, API);
    return u.pathname;
  } catch {
    // already relative
    return url.replace(API, '');
  }
}
function toAbsolute(url){ return `${API}${toRelative(url)}`; }

/* ---------- Back-compat fetch for labels (relative first, then absolute) ---------- */
async function fetchLabelsNormalized(queryRel){
  const headers = { Authorization: `Bearer ${TOKEN}` };

  // try with relative
  let res = await fetch(`${API}/api/labels/get?queryImage=${encodeURIComponent(queryRel)}`, { headers });
  if(res.ok){
    const data = await res.json();
    const any = (data.positives?.length||0) + (data.negatives?.length||0);
    if(any){
      return {
        queryImage: queryRel,
        positives: (data.positives||[]).map(x => toRelative(String(x).trim())),
        negatives: (data.negatives||[]).map(x => toRelative(String(x).trim()))
      };
    }
  }

  // try with absolute (old saves)
  const abs = `${API}${queryRel}`;
  res = await fetch(`${API}/api/labels/get?queryImage=${encodeURIComponent(abs)}`, { headers });
  if(res.ok){
    const data = await res.json();
    const any = (data.positives?.length||0) + (data.negatives?.length||0);
    if(any){
      return {
        queryImage: queryRel,
        positives: (data.positives||[]).map(x => toRelative(String(x).trim())),
        negatives: (data.negatives||[]).map(x => toRelative(String(x).trim()))
      };
    }
  }

  return { queryImage: queryRel, positives: [], negatives: [] };
}

function initApp(){
  const params = new URLSearchParams(window.location.search);
  const queryNum = params.get("query");

  const grid = document.getElementById('grid');
  const queryImg = document.getElementById('queryImg');
  const status = document.getElementById('status');
  const batchCounter = document.getElementById('batchCounter');

  const selected = new Map();         // idx -> 'pos' | 'neg'
  const savedSelections = new Map();  // queryRel -> {positives, negatives}
  const badgeMap = new Map();         // imgRel -> [{posEl,negEl}...]

  let currentIndex = 0;
  let batchIndex = 0;
  let totalBatches = 0;

  function setStatus(msg){ status.textContent = msg || ''; }

  function removeExistingBadges(container){
    container.querySelectorAll('.badge').forEach(b => b.remove());
  }
  function createBadge(text, cls){
    const b = document.createElement('div');
    b.className = `badge ${cls}`;
    b.textContent = String(text ?? 0);
    return b;
  }
  function attachBadgesForUrl(container, urlRel){
    const pos = createBadge(0, 'pos');
    const neg = createBadge(0, 'neg');
    container.appendChild(pos); container.appendChild(neg);
    const pair = { posEl: pos, negEl: neg };
    const arr = badgeMap.get(urlRel) || [];
    arr.push(pair); badgeMap.set(urlRel, arr);
  }
  function setBadgeCounts(urlRel, posCount, negCount){
    const arr = badgeMap.get(urlRel);
    if(!arr) return;
    for(const pair of arr){
      pair.posEl.textContent = String(posCount ?? 0);
      pair.negEl.textContent = String(negCount ?? 0);
    }
  }

  function card(urlRel,index){
    const d=document.createElement('div'); d.className='card';
    const img=document.createElement('img');
img.src=toAbsolute(urlRel);
img.draggable=false;
d.appendChild(img);

const caption=document.createElement('p');
caption.textContent = urlRel.split('/').pop(); // filename only
caption.style.textAlign='center';
caption.style.fontSize='9px';
caption.style.opacity='0.8';
caption.style.margin='0 0 0';
d.appendChild(caption);

    attachBadgesForUrl(d, urlRel);

    d.addEventListener('click',()=>{
      currentIndex=index;
      const cur=selected.get(index);
      if(cur==='pos') selected.delete(index);
      else selected.set(index,'pos');
      updateFocusAndState();
    });
    d.addEventListener('contextmenu',e=>{
      e.preventDefault();
      currentIndex=index;
      selected.set(index,'neg');
      updateFocusAndState();
      return false;
    });
    return d;
  }

  function updateBatchCounter(){ batchCounter.textContent=`${batchIndex+1} / ${totalBatches}`; }

  function updateFocusAndState(){
    const cards=grid.getElementsByClassName('card');
    Array.from(cards).forEach((c,idx)=>{
      const state=selected.get(idx);
      c.classList.remove('pos','neg'); c.style.outline='';
      if(state==='pos') c.classList.add('pos');
      else if(state==='neg') c.classList.add('neg');
      if(idx===currentIndex){
        c.style.outline='4px solid #3b82f6'; c.style.outlineOffset='-2px';
        c.scrollIntoView({behavior:'smooth',block:'nearest'});
      }
    });
    updateBatchCounter();
  }

  async function fetchBatch(batch){
    setStatus('Loading batch...');
    selected.clear();
    badgeMap.clear();
    grid.innerHTML='';

    try{
      const res=await fetch(`${API}/api/batch/${batch}`,{headers:{Authorization:`Bearer ${TOKEN}`}});
      if(!res.ok) throw new Error('Failed to load batch');
      const data=await res.json();

      // Normalize query + candidates to relative
      const queryRel = toRelative(data.queryImage);
      const imgsRel = (data.images||[]).map(toRelative);

      // set query image & badges
      queryImg.src=toAbsolute(queryRel);
      // Show name under query image
let nameEl = document.getElementById('queryName');
if(!nameEl){
  nameEl = document.createElement('p');
  nameEl.id = 'queryName';
  nameEl.style.textAlign='center';
  nameEl.style.fontSize='14px';
  nameEl.style.opacity='0.8';
  nameEl.style.marginTop='8px';
  queryImg.parentElement.after(nameEl);
}
nameEl.textContent = queryRel.split('/').pop();

      const qWrap = queryImg.parentElement;
      removeExistingBadges(qWrap);
      attachBadgesForUrl(qWrap, queryRel);

      // candidates UI
      imgsRel.forEach((u,i)=>grid.appendChild(card(u,i)));

      // === hydrate saved selections from backend (relative-first, then absolute) ===
      try {
        const sv = await fetchLabelsNormalized(queryRel);
        savedSelections.set(queryRel, { positives: sv.positives||[], negatives: sv.negatives||[] });
      } catch(e){ console.warn("could not load saved labels", e); }

      // apply saved selections to UI (green/red borders)
      selected.clear();
      const saved = savedSelections.get(queryRel)||{};
      grid.querySelectorAll('.card').forEach((c,idx)=>{
        const imgRel = toRelative(c.querySelector('img').src);
        if(saved.positives?.includes(imgRel)) selected.set(idx,'pos');
        if(saved.negatives?.includes(imgRel)) selected.set(idx,'neg');
      });

      // init + fetch stats for badges
      setBadgeCounts(queryRel,0,0);
      imgsRel.forEach(u=>setBadgeCounts(u,0,0));
      await refreshStats([queryRel, ...imgsRel]);

      currentIndex=0;
      updateFocusAndState();
      setStatus('Batch loaded. Select matches and click Save or ctrl+ →');
      localStorage.setItem('currentBatch', String(batchIndex));
    }catch(err){
      console.warn("Query fetch failed, fallback to batch 0", err);
      await fetchBatch(0);
    }
  }

  async function fetchTotalBatches(){
    try{
      const res=await fetch(`${API}/api/batches/count`,{headers:{Authorization:`Bearer ${TOKEN}`}});
      const data=await res.json();
      totalBatches=data.total;
      updateBatchCounter();
    }catch(err){ console.error(err); totalBatches=0; }
  }

  async function refreshStats(imagesRel){
    try{
      const res = await fetch(`${API}/api/image_stats/bulk`, {
        method: 'POST',
        headers: {'Content-Type':'application/json', Authorization:`Bearer ${TOKEN}`},
        body: JSON.stringify({ images: imagesRel })
      });
      if(!res.ok) throw new Error('stats fetch failed');
      const data = await res.json();
      const stats = data.stats || {};
      Object.keys(stats).forEach(url=>{
        const s = stats[url] || {};
        setBadgeCounts(toRelative(url), s.positive_count||0, s.negative_count||0);
      });
    }catch(e){ console.error('stats error', e); }
  }

  async function saveSelections(autoNext=false){
    const positives=[], negatives=[];
    const cards=grid.getElementsByClassName('card');
    Array.from(cards).forEach((c,idx)=>{
      const state=selected.get(idx);
      const rel = toRelative(c.querySelector('img').src);
      if(state==='pos') positives.push(rel);
      if(state==='neg') negatives.push(rel);
    });
    const queryRel=toRelative(queryImg.src);
    const body={queryImage:queryRel, positives, negatives};
    setStatus('Saving...');
    try{
      const res=await fetch(`${API}/api/labels/save`,{
        method:'POST',headers:{'Content-Type':'application/json',Authorization:`Bearer ${TOKEN}`},
        body:JSON.stringify(body)
      });
      if(!res.ok) throw new Error('Save failed');
      await res.json();
      savedSelections.set(body.queryImage,{positives,negatives});
      setStatus('Saved ✓');
      const visible=[queryRel,...Array.from(cards).map(c=>toRelative(c.querySelector('img').src))];
      await refreshStats(visible);
      if(autoNext && batchIndex<totalBatches-1){
        batchIndex++;
        localStorage.setItem('currentBatch', String(batchIndex));
        fetchBatch(batchIndex);
      }
    }catch(err){ console.error(err); setStatus(err.message); }
  }

  document.getElementById('nextBatch').addEventListener('click',()=>saveSelections(true));
  document.getElementById('prevBatch').addEventListener('click',()=>saveSelections(false).then(()=>{
    if(batchIndex>0){
      batchIndex--;
      localStorage.setItem('currentBatch', String(batchIndex));
      fetchBatch(batchIndex);
    }
  }));

  window.addEventListener('keydown',e=>{
    const cards=grid.getElementsByClassName('card');
    if(!cards.length) return;
    const cols=Math.floor(grid.clientWidth/(cards[0].offsetWidth+10));
    if(e.key==='ArrowRight' && !e.ctrlKey) currentIndex=Math.min(currentIndex+1,cards.length-1);
    else if(e.key==='ArrowLeft' && !e.ctrlKey) currentIndex=Math.max(currentIndex-1,0);
    else if(e.key==='ArrowDown' && !e.ctrlKey) currentIndex=Math.min(currentIndex+cols,cards.length-1);
    else if(e.key==='ArrowUp' && !e.ctrlKey) currentIndex=Math.max(currentIndex-cols,0);
    else if(e.key===' '){
      const cur=selected.get(currentIndex);
      if(!cur) selected.set(currentIndex,'pos');
      else if(cur==='pos') selected.set(currentIndex,'neg');
      else if(cur==='neg') selected.delete(currentIndex);
      e.preventDefault();
    }
    else if(e.ctrlKey && e.key==='ArrowRight'){ saveSelections(true); e.preventDefault(); }
    else if(e.ctrlKey && e.key==='ArrowLeft'){
      saveSelections(false).then(()=>{
        if(batchIndex>0){
          batchIndex--;
          localStorage.setItem('currentBatch', String(batchIndex));
          fetchBatch(batchIndex);
        }
      });
      e.preventDefault();
    }
    updateFocusAndState();
  });

  document.getElementById('save').addEventListener('click',()=>saveSelections(false));

  // initial load: prefer ?query; else persisted; else 0
  fetchTotalBatches().then(async()=>{
    const persisted=localStorage.getItem('currentBatch');
    if(queryNum!==null){ batchIndex=parseInt(queryNum,10)||0; }
    else if(persisted!==null){ batchIndex=parseInt(persisted,10)||0; }
    else { batchIndex=0; }
    await fetchBatch(batchIndex);
  });
}

initApp();
</script>
</body>
</html>
