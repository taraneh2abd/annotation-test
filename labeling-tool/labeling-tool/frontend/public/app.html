<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simple Image Labeling Tool</title>
<style>
.card.focus { box-shadow: 0 0 0 5px #3b82f6 inset; }
.card.pos.focus { box-shadow: 0 0 0 5px #10b981 inset; }
.card.neg.focus { box-shadow: 0 0 0 5px #ef4444 inset; }

body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 0; background: #0f172a; color: #e2e8f0; }
header { padding: 16px 24px; background: #111827; position: sticky; top: 0; z-index: 10; display: flex; align-items: center; gap: 12px; }
h1 { font-size: 20px; margin: 0; }
.container { padding: 16px 24px; }
.toolbar { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; align-items: center; }
button { background: #1f2937; color: #e5e7eb; border: 1px solid #334155; padding: 8px 12px; border-radius: 10px; cursor: pointer; }
button:hover { background: #374151; }
.status { opacity: 0.8; font-size: 14px; }
.query { margin: 16px 0; text-align: center; }
.query img { max-height: 240px; border-radius: 12px; display: inline-block; border: 1px solid #334155; }
.grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; max-height: 450px; overflow-y: auto; padding: 20px;}
.card { position: relative; border-radius: 12px; overflow: hidden; background: #0b1220; border: 1px solid #334155; cursor: pointer; }
.card img { width: 100%; height: 140px; object-fit: cover; display: block; }
.pos { box-shadow: 0 0 0 3px #10b981 inset; }
.neg { box-shadow: 0 0 0 3px #ef4444 inset; }
.hint { font-size: 13px; opacity: .8; }
.footer { padding: 16px 24px; opacity: 0.7; font-size: 13px; }
a { color: #93c5fd; }

.layout { display: flex; gap: 20px; }
.left-panel { flex: 1; display: flex; flex-direction: column; gap: 16px; align-items: center; }
.right-panel { flex: 5; }
.controls { display: flex; gap: 10px; align-items: center; }
.batch-nav { display: flex; flex-direction: column; align-items: center; gap: 6px; }
.batch-nav .controls-row { display: flex; align-items: center; gap: 8px; }
.batch-nav .hints { font-size: 13px; color: #cbd5e1; line-height: 1.4; text-align: center; }
.batch-nav button { padding: 6px 10px; font-weight: bold; }

/* wrap just the query image so badges overlay correctly */
.queryWrap { position: relative; display: inline-block; }
.queryWrap .badge.pos { left: 6px; top: 6px; }
.queryWrap .badge.neg { right: 6px; top: 6px; }

/* circular badges */
.badge {
  position: absolute;
  top: 6px;
  width: 22px;
  height: 22px;
  line-height: 22px;
  border-radius: 50%;
  font-size: 12px;
  font-weight: bold;
  text-align: center;
  color: #fff;
  pointer-events: none;
}
.badge.pos { left: 6px; background-color: #10b981; }
.badge.neg { right: 6px; background-color: #ef4444; }
</style>
</head>
<body>
<header>
  <h1>Image Labeling Tool</h1>
  <div class="status" id="status"></div>
</header>

<div class="container">
  <div class="layout">
    <div class="left-panel">
      <section class="query">
        <h3>Query Image</h3>
        <div class="queryWrap">
          <img id="queryImg" alt="Query" />
          <!-- badges injected by JS -->
        </div>
      </section>

      <div class="batch-nav">
        <div class="controls-row">
          <button id="prevBatch">&lt;</button>
          <span id="batchCounter">0 / 0</span>
          <button id="nextBatch">&gt;</button>
        </div>
        <div class="hints">
          <p><strong>Ctrl → Ctrl ←</strong> will save automatically</p>
          <p><strong>Left click:</strong> positive, <strong>Right click:</strong> negative</p>
        </div>
      </div>

      <div class="controls">
        <button id="save">Save Selections</button>
      </div>
    </div>

    <div class="right-panel">
      <section>
        <h3>Candidates</h3>
        <div class="grid" id="grid"></div>
      </section>
    </div>
  </div>
</div>

<script>
const API = 'http://localhost:8000';
const TOKEN = localStorage.getItem('TOKEN');
if(!TOKEN) window.location.href='index.html';

function initApp(){
  const params = new URLSearchParams(window.location.search);
  const queryNum = params.get("query");
  const grid = document.getElementById('grid');
  const queryImg = document.getElementById('queryImg');
  const status = document.getElementById('status');
  const batchCounter = document.getElementById('batchCounter');
  const selected = new Map();
  const savedSelections = new Map();

  // Map: imageUrl -> Array<{posEl, negEl}> for *currently visible* elements
  const badgeMap = new Map();

  let currentIndex = 0;
  let batchIndex = 0;
  let totalBatches = 0;

  function setStatus(msg){ status.textContent = msg || ''; }

  function removeExistingBadges(container){
    container.querySelectorAll('.badge').forEach(b => b.remove());
  }

  function createBadge(text, cls){
    const b = document.createElement('div');
    b.className = `badge ${cls}`;
    b.textContent = String(text ?? 0);
    return b;
  }

  // Always create new badges for the given container and register them
  function attachBadgesForUrl(container, url){
    const pos = createBadge(0, 'pos');
    const neg = createBadge(0, 'neg');
    container.appendChild(pos);
    container.appendChild(neg);
    const pair = { posEl: pos, negEl: neg };
    const arr = badgeMap.get(url) || [];
    arr.push(pair);
    badgeMap.set(url, arr);
    return pair;
  }

  function setBadgeCounts(url, posCount, negCount){
    const arr = badgeMap.get(url);
    if(!arr) return;
    for(const pair of arr){
      pair.posEl.textContent = String(posCount ?? 0);
      pair.negEl.textContent = String(negCount ?? 0);
    }
  }

  function card(url,index){
    const d=document.createElement('div');
    d.className='card';
    const img=document.createElement('img');
    img.src=`${API}${url}`;
    img.draggable=false;
    d.appendChild(img);

    // badges for this candidate (always create fresh for this container)
    attachBadgesForUrl(d, url);

    d.addEventListener('click',()=>{
      currentIndex=index;
      const cur=selected.get(index);
      if(cur==='pos') selected.delete(index);
      else selected.set(index,'pos');
      updateFocusAndState();
    });
    d.addEventListener('contextmenu',e=>{
      e.preventDefault();
      currentIndex=index;
      selected.set(index,'neg');
      updateFocusAndState();
      return false;
    });
    return d;
  }

  function updateBatchCounter(){ batchCounter.textContent=`${batchIndex+1} / ${totalBatches}`; }

  function updateFocusAndState(){
    const cards=grid.getElementsByClassName('card');
    Array.from(cards).forEach((c,idx)=>{
      const state=selected.get(idx);
      c.classList.remove('pos','neg');
      c.style.outline='';
      if(state==='pos') c.classList.add('pos');
      else if(state==='neg') c.classList.add('neg');
      if(idx===currentIndex){
        c.style.outline='4px solid #3b82f6';
        c.style.outlineOffset='-2px';
        c.scrollIntoView({behavior:'smooth',block:'nearest'});
      }
    });
    updateBatchCounter();
  }

  async function fetchBatch(batch){
    setStatus('Loading batch...');
    selected.clear();
    badgeMap.clear();               // NEW: reset mapping for new DOM
    grid.innerHTML='';

    try{
      const res=await fetch(`${API}/api/batch/${batch}`,{headers:{Authorization:`Bearer ${TOKEN}`}});
      if(!res.ok) throw new Error('Failed to load batch');
      const data=await res.json();

      // query image
      queryImg.src=`${API}${data.queryImage}`;
      const queryUrl = data.queryImage;
      const qWrap = queryImg.parentElement;

      // remove old badges from the persistent query wrapper and reattach fresh ones
      removeExistingBadges(qWrap);
      attachBadgesForUrl(qWrap, queryUrl);

      // candidates
      data.images.forEach((u,i)=>grid.appendChild(card(u,i)));

      // hydrate saved selections from server
      try {
        const resSaved = await fetch(`${API}/api/labels/get?queryImage=${encodeURIComponent(queryUrl)}`, {
          headers: { Authorization: `Bearer ${TOKEN}` }
        });
        if(resSaved.ok){
          const sv = await resSaved.json();
          savedSelections.set(queryUrl, { positives: sv.positives||[], negatives: sv.negatives||[] });
        }
      } catch(e){ console.warn("could not load saved labels", e); }

      // apply to UI
      selected.clear();
      const saved = savedSelections.get(queryUrl)||{};
      grid.querySelectorAll('.card').forEach((c,idx)=>{
        const imgUrl=c.querySelector('img').src.replace(API,'');
        if(saved.positives?.includes(imgUrl)) selected.set(idx,'pos');
        if(saved.negatives?.includes(imgUrl)) selected.set(idx,'neg');
      });

      // init counts for visible items and fetch stats
      setBadgeCounts(queryUrl,0,0);
      data.images.forEach(u=>setBadgeCounts(u,0,0));
      await refreshStats([queryUrl, ...data.images]);

      currentIndex=0;
      updateFocusAndState();
      setStatus('Batch loaded. Select matches and click Save or ctrl+ →');
      localStorage.setItem('currentBatch', String(batchIndex));
    }catch(err){
      console.warn("Query fetch failed, fallback to batch 0", err);
      await fetchBatch(0);
    }
  }

  async function fetchTotalBatches(){
    try{
      const res=await fetch(`${API}/api/batches/count`,{headers:{Authorization:`Bearer ${TOKEN}`}});
      const data=await res.json();
      totalBatches=data.total;
      updateBatchCounter();
    }catch(err){ console.error(err); totalBatches=0; }
  }

  async function refreshStats(images){
    try{
      const res = await fetch(`${API}/api/image_stats/bulk`, {
        method: 'POST',
        headers: {'Content-Type':'application/json', Authorization:`Bearer ${TOKEN}`},
        body: JSON.stringify({ images })
      });
      if(!res.ok) throw new Error('stats fetch failed');
      const data = await res.json();
      const stats = data.stats || {};
      Object.keys(stats).forEach(url=>{
        const s = stats[url] || {};
        setBadgeCounts(url, s.positive_count||0, s.negative_count||0);
      });
    }catch(e){ console.error('stats error', e); }
  }

  async function saveSelections(autoNext=false){
    const positives=[], negatives=[];
    const cards=grid.getElementsByClassName('card');
    Array.from(cards).forEach((c,idx)=>{
      const state=selected.get(idx);
      if(state==='pos') positives.push(c.querySelector('img').src.replace(API,''));
      if(state==='neg') negatives.push(c.querySelector('img').src.replace(API,''));
    });
    const queryUrl=queryImg.src.replace(API,'');
    const body={queryImage:queryUrl, positives, negatives};
    setStatus('Saving...');
    try{
      const res=await fetch(`${API}/api/labels/save`,{
        method:'POST',headers:{'Content-Type':'application/json',Authorization:`Bearer ${TOKEN}`},
        body:JSON.stringify(body)
      });
      if(!res.ok) throw new Error('Save failed');
      await res.json();
      savedSelections.set(body.queryImage,{positives,negatives});
      setStatus('Saved ✓');
      const visible=[queryUrl,...Array.from(cards).map(c=>c.querySelector('img').src.replace(API,''))];
      await refreshStats(visible);
      if(autoNext && batchIndex<totalBatches-1){
        batchIndex++;
        localStorage.setItem('currentBatch', String(batchIndex));
        fetchBatch(batchIndex);
      }
    }catch(err){ console.error(err); setStatus(err.message);}
  }

  document.getElementById('nextBatch').addEventListener('click',()=>saveSelections(true));
  document.getElementById('prevBatch').addEventListener('click',()=>saveSelections(false).then(()=>{
    if(batchIndex>0){
      batchIndex--;
      localStorage.setItem('currentBatch', String(batchIndex));
      fetchBatch(batchIndex);
    }
  }));

  window.addEventListener('keydown',e=>{
    const cards=grid.getElementsByClassName('card');
    if(!cards.length) return;
    const cols=Math.floor(grid.clientWidth/(cards[0].offsetWidth+10));
    if(e.key==='ArrowRight' && !e.ctrlKey) currentIndex=Math.min(currentIndex+1,cards.length-1);
    else if(e.key==='ArrowLeft' && !e.ctrlKey) currentIndex=Math.max(currentIndex-1,0);
    else if(e.key==='ArrowDown' && !e.ctrlKey) currentIndex=Math.min(currentIndex+cols,cards.length-1);
    else if(e.key==='ArrowUp' && !e.ctrlKey) currentIndex=Math.max(currentIndex-cols,0);
    else if(e.key===' '){
      const cur=selected.get(currentIndex);
      if(!cur) selected.set(currentIndex,'pos');
      else if(cur==='pos') selected.set(currentIndex,'neg');
      else if(cur==='neg') selected.delete(currentIndex);
      e.preventDefault();
    }
    else if(e.ctrlKey && e.key==='ArrowRight'){
      saveSelections(true); e.preventDefault();
    }
    else if(e.ctrlKey && e.key==='ArrowLeft'){
      saveSelections(false).then(()=>{
        if(batchIndex>0){
          batchIndex--;
          localStorage.setItem('currentBatch', String(batchIndex));
          fetchBatch(batchIndex);
        }
      });
      e.preventDefault();
    }
    updateFocusAndState();
  });

  document.getElementById('save').addEventListener('click',()=>saveSelections(false));

  // Load batches: use query param, or persisted, or default to 0
  fetchTotalBatches().then(async()=>{
    const persisted=localStorage.getItem('currentBatch');
    if(queryNum!==null){ batchIndex=parseInt(queryNum,10)||0; }
    else if(persisted!==null){ batchIndex=parseInt(persisted,10)||0; }
    else { batchIndex=0; }
    await fetchBatch(batchIndex);
  });
}

initApp();
</script>
</body>
</html>
